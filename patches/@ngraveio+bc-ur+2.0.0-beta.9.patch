diff --git a/node_modules/@ngraveio/bc-ur/dist/esm/wrappers/cbor2.js b/node_modules/@ngraveio/bc-ur/dist/esm/wrappers/cbor2.js
index a8a75d7..6a7b30f 100644
--- a/node_modules/@ngraveio/bc-ur/dist/esm/wrappers/cbor2.js
+++ b/node_modules/@ngraveio/bc-ur/dist/esm/wrappers/cbor2.js
@@ -3,7 +3,7 @@
 // Dual package hazard, in turn both esm and commonjs will use the same cbor2Wrapper.js
 // So we only have one source of truth for cbor2
 //@ts-ignore
-export { decode, encode, Tag, registerEncoder, comment, diagnose } from "../../commonjs/wrappers/cbor2Wrapper.js";
-// export { decode, encode, Tag, registerEncoder } from "./cbor2Wrapper.js";
+// export { decode, encode, Tag, registerEncoder, comment, diagnose } from "../../commonjs/wrappers/cbor2Wrapper.js";
+export { decode, encode, Tag, registerEncoder, comment, diagnose } from "./cbor2Wrapper.js";
 // export type { DecodeOptions, EncodeOptions } from "./cbor2Wrapper.js";
 //# sourceMappingURL=cbor2.js.map
\ No newline at end of file
diff --git a/node_modules/@ngraveio/bc-ur/dist/esm/wrappers/cbor2Wrapper-fixed.js b/node_modules/@ngraveio/bc-ur/dist/esm/wrappers/cbor2Wrapper-fixed.js
new file mode 100644
index 0000000..95ada7d
--- /dev/null
+++ b/node_modules/@ngraveio/bc-ur/dist/esm/wrappers/cbor2Wrapper-fixed.js
@@ -0,0 +1,48 @@
+
+const f$4={POS_INT:0,NEG_INT:1,BYTE_STRING:2,UTF8_STRING:3,ARRAY:4,MAP:5,TAG:6,SIMPLE_FLOAT:7},I$3={DATE_STRING:0,DATE_EPOCH:1,POS_BIGINT:2,NEG_BIGINT:3,DECIMAL_FRAC:4,BIGFLOAT:5,BASE64URL_EXPECTED:21,BASE64_EXPECTED:22,BASE16_EXPECTED:23,CBOR:24,URI:32,BASE64URL:33,BASE64:34,MIME:36,SET:258,JSON:262,REGEXP:21066,SELF_DESCRIBED:55799,INVALID_16:65535,INVALID_32:4294967295,INVALID_64:0xffffffffffffffffn},o$2={ZERO:0,ONE:24,TWO:25,FOUR:26,EIGHT:27,INDEFINITE:31},T$1={FALSE:20,TRUE:21,NULL:22,UNDEFINED:23};let N$1 = class N{static BREAK=Symbol.for("github.com/hildjj/cbor2/break");static ENCODED=Symbol.for("github.com/hildjj/cbor2/cbor-encoded");static LENGTH=Symbol.for("github.com/hildjj/cbor2/length")};const S$1={MIN:-(2n**63n),MAX:2n**64n-1n};
+
+let i$1 = class i{static#e=new Map;tag;contents;constructor(t,e=undefined){this.tag=t,this.contents=e;}get noChildren(){return !!i.#e.get(this.tag)?.noChildren}static registerDecoder(t,e,n){const o=this.#e.get(t);return this.#e.set(t,e),o&&("comment"in e||(e.comment=o.comment),"noChildren"in e||(e.noChildren=o.noChildren)),n&&!e.comment&&(e.comment=()=>`(${n})`),o}static clearDecoder(t){const e=this.#e.get(t);return this.#e.delete(t),e}static getDecoder(t){return this.#e.get(t)}static getAllDecoders(){return new Map(this.#e)}*[Symbol.iterator](){yield this.contents;}push(t){return this.contents=t,1}decode(t){const e=i.#e.get(this.tag);return e?e(this,t):this}comment(t,e){const n=i.#e.get(this.tag);if(n?.comment)return n.comment(this,t,e)}toCBOR(){return [this.tag,this.contents]}[Symbol.for("nodejs.util.inspect.custom")](t,e,n){return `${this.tag}(${n(this.contents,e)})`}};
+
+function f$3(n){if(n!=null&&typeof n=="object")return n[N$1.ENCODED]}function s$2(n){if(n!=null&&typeof n=="object")return n[N$1.LENGTH]}function u$2(n,e){Object.defineProperty(n,N$1.ENCODED,{configurable:true,enumerable:false,value:e});}function d$1(n,e){const r=Object(n);return u$2(r,e),r}
+
+function c$1(n){let t=Math.ceil(n.length/2);const r=new Uint8Array(t);t--;for(let e=n.length,o=e-2;e>=0;e=o,o-=2,t--)r[t]=parseInt(n.substring(o,e),16);return r}function u$1(n){return n.reduce((t,r)=>t+r.toString(16).padStart(2,"0"),"")}function g$2(n){const t=n.reduce((o,i)=>o+i.length,0),r=new Uint8Array(t);let e=0;for(const o of n)r.set(o,e),e+=o.length;return r}function s$1(n){const t=atob(n);return Uint8Array.from(t,r=>r.codePointAt(0))}const a$2={"-":"+",_:"/"};function l$2(n){const t=n.replace(/[_-]/g,r=>a$2[r]);return s$1(t.padEnd(Math.ceil(t.length/4)*4,"="))}function f$2(){const n=new Uint8Array(4),t=new Uint32Array(n.buffer);return !((t[0]=1)&n[0])}function y$1(n){let t="";for(const r of n){const e=r.codePointAt(0)?.toString(16).padStart(4,"0");t&&(t+=", "),t+=`U+${e}`;}return t}
+
+function f$1(c,d){const[u,a,n]=c,[l,s,t]=d,r=Math.min(n.length,t.length);for(let o=0;o<r;o++){const e=n[o]-t[o];if(e!==0)return e}return 0}
+
+class e{static defaultOptions={chunkSize:4096};#r;#i=[];#s=null;#t=0;#a=0;constructor(t={}){if(this.#r={...e.defaultOptions,...t},this.#r.chunkSize<8)throw new RangeError(`Expected size >= 8, got ${this.#r.chunkSize}`);this.#n();}get length(){return this.#a}read(){this.#l();const t=new Uint8Array(this.#a);let i=0;for(const s of this.#i)t.set(s,i),i+=s.length;return this.#n(),t}write(t){const i=t.length;i>this.#o()?(this.#l(),i>this.#r.chunkSize?(this.#i.push(t),this.#n()):(this.#n(),this.#i[this.#i.length-1].set(t),this.#t=i)):(this.#i[this.#i.length-1].set(t,this.#t),this.#t+=i),this.#a+=i;}writeUint8(t){this.#e(1),this.#s.setUint8(this.#t,t),this.#h(1);}writeUint16(t,i=false){this.#e(2),this.#s.setUint16(this.#t,t,i),this.#h(2);}writeUint32(t,i=false){this.#e(4),this.#s.setUint32(this.#t,t,i),this.#h(4);}writeBigUint64(t,i=false){this.#e(8),this.#s.setBigUint64(this.#t,t,i),this.#h(8);}writeInt16(t,i=false){this.#e(2),this.#s.setInt16(this.#t,t,i),this.#h(2);}writeInt32(t,i=false){this.#e(4),this.#s.setInt32(this.#t,t,i),this.#h(4);}writeBigInt64(t,i=false){this.#e(8),this.#s.setBigInt64(this.#t,t,i),this.#h(8);}writeFloat32(t,i=false){this.#e(4),this.#s.setFloat32(this.#t,t,i),this.#h(4);}writeFloat64(t,i=false){this.#e(8),this.#s.setFloat64(this.#t,t,i),this.#h(8);}clear(){this.#a=0,this.#i=[],this.#n();}#n(){const t=new Uint8Array(this.#r.chunkSize);this.#i.push(t),this.#t=0,this.#s=new DataView(t.buffer,t.byteOffset,t.byteLength);}#l(){if(this.#t===0){this.#i.pop();return}const t=this.#i.length-1;this.#i[t]=this.#i[t].subarray(0,this.#t),this.#t=0,this.#s=null;}#o(){const t=this.#i.length-1;return this.#i[t].length-this.#t}#e(t){this.#o()<t&&(this.#l(),this.#n());}#h(t){this.#t+=t,this.#a+=t;}}
+
+function o$1(e,n=0,t=false){const r=e[n]&128?-1:1,f=(e[n]&124)>>2,a=(e[n]&3)<<8|e[n+1];if(f===0){if(t&&a!==0)throw new Error(`Unwanted subnormal: ${r*5960464477539063e-23*a}`);return r*5960464477539063e-23*a}else if(f===31)return a?NaN:r*(1/0);return r*2**(f-25)*(1024+a)}function s(e){const n=new DataView(new ArrayBuffer(4));n.setFloat32(0,e,false);const t=n.getUint32(0,false);if(t&8191)return null;let r=t>>16&32768;const f=t>>23&255,a=t&8388607;if(!(f===0&&a===0))if(f>=113&&f<=142)r+=(f-112<<10)+(a>>13);else if(f>=103&&f<113){if(a&(1<<126-f)-1)return null;r+=a+8388608>>126-f;}else if(f===255)r|=31744,r|=a>>13;else return null;return r}function i(e){if(e!==0){const n=new ArrayBuffer(8),t=new DataView(n);t.setFloat64(0,e,false);const r=t.getBigUint64(0,false);if((r&0x7ff0000000000000n)===0n)return r&0x8000000000000000n?-0:0}return e}function l$1(e){switch(e.length){case 2:o$1(e,0,true);break;case 4:{const n=new DataView(e.buffer,e.byteOffset,e.byteLength),t=n.getUint32(0,false);if(!(t&2139095040)&&t&8388607)throw new Error(`Unwanted subnormal: ${n.getFloat32(0,false)}`);break}case 8:{const n=new DataView(e.buffer,e.byteOffset,e.byteLength),t=n.getBigUint64(0,false);if((t&0x7ff0000000000000n)===0n&&t&0x000fffffffffffn)throw new Error(`Unwanted subnormal: ${n.getFloat64(0,false)}`);break}default:throw new TypeError(`Bad input to isSubnormal: ${e}`)}}
+
+const O$5=f$4.SIMPLE_FLOAT<<5|o$2.TWO,h$1=f$4.SIMPLE_FLOAT<<5|o$2.FOUR,B$1=f$4.SIMPLE_FLOAT<<5|o$2.EIGHT,C$1=f$4.SIMPLE_FLOAT<<5|T$1.TRUE,j=f$4.SIMPLE_FLOAT<<5|T$1.FALSE,W=f$4.SIMPLE_FLOAT<<5|T$1.UNDEFINED,P=f$4.SIMPLE_FLOAT<<5|T$1.NULL,q=new TextEncoder,k$2={...e.defaultOptions,avoidInts:false,cde:false,collapseBigInts:true,dcbor:false,float64:false,flushToZero:false,forceEndian:null,ignoreOriginalEncoding:false,largeNegativeAsBigInt:false,reduceUnsafeNumbers:false,rejectBigInts:false,rejectCustomSimples:false,rejectDuplicateKeys:false,rejectFloats:false,rejectUndefined:false,simplifyNegativeZero:false,sortKeys:null,stringNormalization:null},R$1={cde:true,ignoreOriginalEncoding:true,sortKeys:f$1},$={...R$1,dcbor:true,largeNegativeAsBigInt:true,reduceUnsafeNumbers:true,rejectCustomSimples:true,rejectDuplicateKeys:true,rejectUndefined:true,simplifyNegativeZero:true,stringNormalization:"NFC"};function I$2(e){const n=e<0;return typeof e=="bigint"?[n?-e-1n:e,n]:[n?-e-1:e,n]}function p$1(e,n,t){if(t.rejectFloats)throw new Error(`Attempt to encode an unwanted floating point number: ${e}`);if(isNaN(e))n.writeUint8(O$5),n.writeUint16(32256);else if(!t.float64&&Math.fround(e)===e){const r=s(e);r===null?(n.writeUint8(h$1),n.writeFloat32(e)):(n.writeUint8(O$5),n.writeUint16(r));}else n.writeUint8(B$1),n.writeFloat64(e);}function a$1(e,n,t){const[r,i]=I$2(e);if(i&&t)throw new TypeError(`Negative size: ${e}`);t??=i?f$4.NEG_INT:f$4.POS_INT,t<<=5,r<24?n.writeUint8(t|r):r<=255?(n.writeUint8(t|o$2.ONE),n.writeUint8(r)):r<=65535?(n.writeUint8(t|o$2.TWO),n.writeUint16(r)):r<=4294967295?(n.writeUint8(t|o$2.FOUR),n.writeUint32(r)):(n.writeUint8(t|o$2.EIGHT),n.writeBigUint64(BigInt(r)));}function U$1(e,n,t){typeof e=="number"?a$1(e,n,f$4.TAG):typeof e=="object"&&!t.ignoreOriginalEncoding&&N$1.ENCODED in e?n.write(e[N$1.ENCODED]):e<=Number.MAX_SAFE_INTEGER?a$1(Number(e),n,f$4.TAG):(n.writeUint8(f$4.TAG<<5|o$2.EIGHT),n.writeBigUint64(BigInt(e)));}function l(e,n,t){const[r,i]=I$2(e);if(t.collapseBigInts&&(!t.largeNegativeAsBigInt||e>=-0x8000000000000000n)){if(r<=0xffffffffn){a$1(Number(e),n);return}if(r<=0xffffffffffffffffn){const E=(i?f$4.NEG_INT:f$4.POS_INT)<<5;n.writeUint8(E|o$2.EIGHT),n.writeBigUint64(r);return}}if(t.rejectBigInts)throw new Error(`Attempt to encode unwanted bigint: ${e}`);const o=i?I$3.NEG_BIGINT:I$3.POS_BIGINT,d=r.toString(16),f=d.length%2?"0":"";U$1(o,n,t);const c=c$1(f+d);a$1(c.length,n,f$4.BYTE_STRING),n.write(c);}function z(e,n,t){t.flushToZero&&(e=i(e)),Object.is(e,-0)?t.simplifyNegativeZero?t.avoidInts?p$1(0,n,t):a$1(0,n):p$1(e,n,t):!t.avoidInts&&Number.isSafeInteger(e)?a$1(e,n):t.reduceUnsafeNumbers&&Math.floor(e)===e&&e>=S$1.MIN&&e<=S$1.MAX?l(BigInt(e),n,t):p$1(e,n,t);}function K(e,n,t){const r=t.stringNormalization?e.normalize(t.stringNormalization):e,i=q.encode(r);a$1(i.length,n,f$4.UTF8_STRING),n.write(i);}function H(e,n,t){const r=e;F(r,r.length,f$4.ARRAY,n,t);for(const i of r)b(i,n,t);}function Z(e,n){const t=e;a$1(t.length,n,f$4.BYTE_STRING),n.write(t);}const m$1=new Map([[Array,H],[Uint8Array,Z]]);function ie(e,n){const t=m$1.get(e);return m$1.set(e,n),t}function F(e,n,t,r,i){const o=s$2(e);o&&!i.ignoreOriginalEncoding?r.write(o):a$1(n,r,t);}function J(e,n,t){if(e===null){n.writeUint8(P);return}if(!t.ignoreOriginalEncoding&&N$1.ENCODED in e){n.write(e[N$1.ENCODED]);return}const r=m$1.get(e.constructor);if(r){const o=r(e,n,t);o&&((typeof o[0]=="bigint"||isFinite(Number(o[0])))&&U$1(o[0],n,t),b(o[1],n,t));return}if(typeof e.toCBOR=="function"){const o=e.toCBOR(n,t);o&&((typeof o[0]=="bigint"||isFinite(Number(o[0])))&&U$1(o[0],n,t),b(o[1],n,t));return}if(typeof e.toJSON=="function"){b(e.toJSON(),n,t);return}const i=Object.entries(e).map(o=>[o[0],o[1],Y(o[0],t)]);t.sortKeys&&i.sort(t.sortKeys),F(e,i.length,f$4.MAP,n,t);for(const[o,d,f]of i)n.write(f),b(d,n,t);}function b(e,n,t){switch(typeof e){case "number":z(e,n,t);break;case "bigint":l(e,n,t);break;case "string":K(e,n,t);break;case "boolean":n.writeUint8(e?C$1:j);break;case "undefined":if(t.rejectUndefined)throw new Error("Attempt to encode unwanted undefined.");n.writeUint8(W);break;case "object":J(e,n,t);break;case "symbol":throw new TypeError(`Unknown symbol: ${e.toString()}`);default:throw new TypeError(`Unknown type: ${typeof e}, ${String(e)}`)}}function Y(e$1,n={}){const t={...k$2};n.dcbor?Object.assign(t,$):n.cde&&Object.assign(t,R$1),Object.assign(t,n);const r=new e(t);return b(e$1,r,t),r.read()}
+
+var o=(e=>(e[e.NEVER=-1]="NEVER",e[e.PREFERRED=0]="PREFERRED",e[e.ALWAYS=1]="ALWAYS",e))(o||{});
+
+class t{static KnownSimple=new Map([[T$1.FALSE,false],[T$1.TRUE,true],[T$1.NULL,null],[T$1.UNDEFINED,undefined]]);value;constructor(e){this.value=e;}static create(e){return t.KnownSimple.has(e)?t.KnownSimple.get(e):new t(e)}toCBOR(e,i){if(i.rejectCustomSimples)throw new Error(`Cannot encode non-standard Simple value: ${this.value}`);a$1(this.value,e,f$4.SIMPLE_FLOAT);}toString(){return `simple(${this.value})`}decode(){return t.KnownSimple.has(this.value)?t.KnownSimple.get(this.value):this}[Symbol.for("nodejs.util.inspect.custom")](e,i,r){return `simple(${r(this.value,i)})`}}
+
+const g$1=new TextDecoder("utf8",{fatal:true,ignoreBOM:true});class u{static defaultOptions={maxDepth:1024,encoding:"hex",requirePreferred:false};#t;#r;#e=0;#i;constructor(t,r){if(this.#i={...u.defaultOptions,...r},typeof t=="string")switch(this.#i.encoding){case "hex":this.#t=c$1(t);break;case "base64":this.#t=s$1(t);break;default:throw new TypeError(`Encoding not implemented: "${this.#i.encoding}"`)}else this.#t=t;this.#r=new DataView(this.#t.buffer,this.#t.byteOffset,this.#t.byteLength);}toHere(t){return this.#t.subarray(t,this.#e)}*[Symbol.iterator](){if(yield*this.#n(0),this.#e!==this.#t.length)throw new Error("Extra data in input")}*#n(t$1){if(t$1++>this.#i.maxDepth)throw new Error(`Maximum depth ${this.#i.maxDepth} exceeded`);const r=this.#e,c=this.#r.getUint8(this.#e++),i=c>>5,n=c&31;let e=n,f=false,a=0;switch(n){case o$2.ONE:if(a=1,e=this.#r.getUint8(this.#e),i===f$4.SIMPLE_FLOAT){if(e<32)throw new Error(`Invalid simple encoding in extra byte: ${e}`);f=true;}else if(this.#i.requirePreferred&&e<24)throw new Error(`Unexpectedly long integer encoding (1) for ${e}`);break;case o$2.TWO:if(a=2,i===f$4.SIMPLE_FLOAT)e=o$1(this.#t,this.#e);else if(e=this.#r.getUint16(this.#e,false),this.#i.requirePreferred&&e<=255)throw new Error(`Unexpectedly long integer encoding (2) for ${e}`);break;case o$2.FOUR:if(a=4,i===f$4.SIMPLE_FLOAT)e=this.#r.getFloat32(this.#e,false);else if(e=this.#r.getUint32(this.#e,false),this.#i.requirePreferred&&e<=65535)throw new Error(`Unexpectedly long integer encoding (4) for ${e}`);break;case o$2.EIGHT:{if(a=8,i===f$4.SIMPLE_FLOAT)e=this.#r.getFloat64(this.#e,false);else if(e=this.#r.getBigUint64(this.#e,false),e<=Number.MAX_SAFE_INTEGER&&(e=Number(e)),this.#i.requirePreferred&&e<=4294967295)throw new Error(`Unexpectedly long integer encoding (8) for ${e}`);break}case 28:case 29:case 30:throw new Error(`Additional info not implemented: ${n}`);case o$2.INDEFINITE:switch(i){case f$4.POS_INT:case f$4.NEG_INT:case f$4.TAG:throw new Error(`Invalid indefinite encoding for MT ${i}`);case f$4.SIMPLE_FLOAT:yield [i,n,N$1.BREAK,r,0];return}e=1/0;break;default:f=true;}switch(this.#e+=a,i){case f$4.POS_INT:yield [i,n,e,r,a];break;case f$4.NEG_INT:yield [i,n,typeof e=="bigint"?-1n-e:-1-Number(e),r,a];break;case f$4.BYTE_STRING:e===1/0?yield*this.#s(i,t$1,r):yield [i,n,this.#a(e),r,e];break;case f$4.UTF8_STRING:e===1/0?yield*this.#s(i,t$1,r):yield [i,n,g$1.decode(this.#a(e)),r,e];break;case f$4.ARRAY:if(e===1/0)yield*this.#s(i,t$1,r,false);else {const o=Number(e);yield [i,n,o,r,a];for(let h=0;h<o;h++)yield*this.#n(t$1+1);}break;case f$4.MAP:if(e===1/0)yield*this.#s(i,t$1,r,false);else {const o=Number(e);yield [i,n,o,r,a];for(let h=0;h<o;h++)yield*this.#n(t$1),yield*this.#n(t$1);}break;case f$4.TAG:yield [i,n,e,r,a],yield*this.#n(t$1);break;case f$4.SIMPLE_FLOAT:{const o=e;f&&(e=t.create(Number(e))),yield [i,n,e,r,o];break}}}#a(t){const r=this.#t.subarray(this.#e,this.#e+=t);if(r.length!==t)throw new Error(`Unexpected end of stream reading ${t} bytes, got ${r.length}`);return r}*#s(t,r,c,i=true){for(yield [t,o$2.INDEFINITE,1/0,c,1/0];;){const n=this.#n(r),e=n.next(),[f,a,o]=e.value;if(o===N$1.BREAK){yield e.value,n.next();return}if(i){if(f!==t)throw new Error(`Unmatched major type.  Expected ${t}, got ${f}.`);if(a===o$2.INDEFINITE)throw new Error("New stream started in typed stream")}yield e.value,yield*n;}}}
+
+const O$4=new Map([[o$2.ZERO,1],[o$2.ONE,2],[o$2.TWO,3],[o$2.FOUR,5],[o$2.EIGHT,9]]),k$1=new Uint8Array(0);function v(d,n){return !n.boxed&&!n.preferMap&&d.every(([i])=>typeof i=="string")?Object.fromEntries(d):new Map(d)}class w{static defaultDecodeOptions={...u.defaultOptions,ParentType:w,boxed:false,cde:false,dcbor:false,diagnosticSizes:o.PREFERRED,convertUnsafeIntsToFloat:false,createObject:v,pretty:false,preferMap:false,rejectLargeNegatives:false,rejectBigInts:false,rejectDuplicateKeys:false,rejectFloats:false,rejectInts:false,rejectLongLoundNaN:false,rejectLongFloats:false,rejectNegativeZero:false,rejectSimple:false,rejectStreaming:false,rejectStringsNotNormalizedAs:null,rejectSubnormals:false,rejectUndefined:false,rejectUnsafeFloatInts:false,saveOriginal:false,sortKeys:null};static cdeDecodeOptions={cde:true,rejectStreaming:true,requirePreferred:true,sortKeys:f$1};static dcborDecodeOptions={...this.cdeDecodeOptions,dcbor:true,convertUnsafeIntsToFloat:true,rejectDuplicateKeys:true,rejectLargeNegatives:true,rejectLongLoundNaN:true,rejectLongFloats:true,rejectNegativeZero:true,rejectSimple:true,rejectUndefined:true,rejectUnsafeFloatInts:true,rejectStringsNotNormalizedAs:"NFC"};parent;mt;ai;left;offset;count=0;children=[];depth=0;#e;#t=null;constructor(n,i,e,t){if([this.mt,this.ai,,this.offset]=n,this.left=i,this.parent=e,this.#e=t,e&&(this.depth=e.depth+1),this.mt===f$4.MAP&&(this.#e.sortKeys||this.#e.rejectDuplicateKeys)&&(this.#t=[]),this.#e.rejectStreaming&&this.ai===o$2.INDEFINITE)throw new Error("Streaming not supported")}get isStreaming(){return this.left===1/0}get done(){return this.left===0}static create(n,i,e,t$1){const[s,l,r,a]=n;switch(s){case f$4.POS_INT:case f$4.NEG_INT:{if(e.rejectInts)throw new Error(`Unexpected integer: ${r}`);if(e.rejectLargeNegatives&&r<-0x8000000000000000n)throw new Error(`Invalid 65bit negative number: ${r}`);let o=r;return e.convertUnsafeIntsToFloat&&o>=S$1.MIN&&o<=S$1.MAX&&(o=Number(r)),e.boxed?d$1(o,t$1.toHere(a)):o}case f$4.SIMPLE_FLOAT:if(l>o$2.ONE){if(e.rejectFloats)throw new Error(`Decoding unwanted floating point number: ${r}`);if(e.rejectNegativeZero&&Object.is(r,-0))throw new Error("Decoding negative zero");if(e.rejectLongLoundNaN&&isNaN(r)){const o=t$1.toHere(a);if(o.length!==3||o[1]!==126||o[2]!==0)throw new Error(`Invalid NaN encoding: "${u$1(o)}"`)}if(e.rejectSubnormals&&l$1(t$1.toHere(a+1)),e.rejectLongFloats){const o=Y(r,{chunkSize:9,reduceUnsafeNumbers:e.rejectUnsafeFloatInts});if(o[0]>>5!==s)throw new Error(`Should have been encoded as int, not float: ${r}`);if(o.length<O$4.get(l))throw new Error(`Number should have been encoded shorter: ${r}`)}if(typeof r=="number"&&e.boxed)return d$1(r,t$1.toHere(a))}else {if(e.rejectSimple&&r instanceof t)throw new Error(`Invalid simple value: ${r}`);if(e.rejectUndefined&&r===undefined)throw new Error("Unexpected undefined")}return r;case f$4.BYTE_STRING:case f$4.UTF8_STRING:if(r===1/0)return new e.ParentType(n,1/0,i,e);if(e.rejectStringsNotNormalizedAs&&typeof r=="string"){const o=r.normalize(e.rejectStringsNotNormalizedAs);if(r!==o)throw new Error(`String not normalized as "${e.rejectStringsNotNormalizedAs}", got [${y$1(r)}] instead of [${y$1(o)}]`)}return e.boxed?d$1(r,t$1.toHere(a)):r;case f$4.ARRAY:return new e.ParentType(n,r,i,e);case f$4.MAP:return new e.ParentType(n,r*2,i,e);case f$4.TAG:{const o=new e.ParentType(n,1,i,e);return o.children=new i$1(r),o}}throw new TypeError(`Invalid major type: ${s}`)}push(n,i,e){if(this.children.push(n),this.#t){const t=f$3(n)||i.toHere(e);this.#t.push(t);}return --this.left}replaceLast(n,i,e){let t,s=-1/0;if(this.children instanceof i$1?(s=0,t=this.children.contents,this.children.contents=n):(s=this.children.length-1,t=this.children[s],this.children[s]=n),this.#t){const l=f$3(n)||e.toHere(i.offset);this.#t[s]=l;}return t}convert(n){let i;switch(this.mt){case f$4.ARRAY:i=this.children;break;case f$4.MAP:{const e=this.#r();if(this.#e.sortKeys){let t;for(const s of e){if(t&&this.#e.sortKeys(t,s)>=0)throw new Error(`Duplicate or out of order key: "0x${s[2]}"`);t=s;}}else if(this.#e.rejectDuplicateKeys){const t=new Set;for(const[s,l,r]of e){const a=u$1(r);if(t.has(a))throw new Error(`Duplicate key: "0x${a}"`);t.add(a);}}i=this.#e.createObject(e,this.#e);break}case f$4.BYTE_STRING:return g$2(this.children);case f$4.UTF8_STRING:{const e=this.children.join("");i=this.#e.boxed?d$1(e,n.toHere(this.offset)):e;break}case f$4.TAG:i=this.children.decode(this.#e);break;default:throw new TypeError(`Invalid mt on convert: ${this.mt}`)}return this.#e.saveOriginal&&i&&typeof i=="object"&&u$2(i,n.toHere(this.offset)),i}#r(){const n=this.children,i=n.length;if(i%2)throw new Error("Missing map value");const e=new Array(i/2);if(this.#t)for(let t=0;t<i;t+=2)e[t>>1]=[n[t],n[t+1],this.#t[t]];else for(let t=0;t<i;t+=2)e[t>>1]=[n[t],n[t+1],k$1];return e}}
+
+class C extends w{depth=0;leaf=false;value;length;[N$1.ENCODED];constructor(a,s,e,n){super(a,s,e,n),this.parent?this.depth=this.parent.depth+1:this.depth=n.initialDepth,[,,this.value,,this.length]=a;}numBytes(){switch(this.ai){case o$2.ONE:return 1;case o$2.TWO:return 2;case o$2.FOUR:return 4;case o$2.EIGHT:return 8}return 0}}function E$1(t){return t instanceof C}function c(t,a){return t===1/0?"Indefinite":a?`${t} ${a}${t!==1&&t!==1n?"s":""}`:String(t)}function O$3(t){return "".padStart(t," ")}function T(t$1,a,s){let e="";e+=O$3(t$1.depth*2);const n=f$3(t$1);e+=u$1(n.subarray(0,1));const i=t$1.numBytes();i&&(e+=" ",e+=u$1(n.subarray(1,i+1))),e=e.padEnd(a.minCol+1," "),e+="-- ",s!==undefined&&(e+=O$3(t$1.depth*2),s!==""&&(e+=`[${s}] `));let u=false;const[r]=t$1.children;switch(t$1.mt){case f$4.POS_INT:e+=`Unsigned: ${r}`,typeof r=="bigint"&&(e+="n");break;case f$4.NEG_INT:e+=`Negative: ${r}`,typeof r=="bigint"&&(e+="n");break;case f$4.BYTE_STRING:e+=`Bytes (Length: ${c(t$1.length)})`;break;case f$4.UTF8_STRING:e+=`UTF8 (Length: ${c(t$1.length)})`,t$1.length!==1/0&&(e+=`: ${JSON.stringify(r)}`);break;case f$4.ARRAY:e+=`Array (Length: ${c(t$1.value,"item")})`;break;case f$4.MAP:e+=`Map (Length: ${c(t$1.value,"pair")})`;break;case f$4.TAG:{e+=`Tag #${t$1.value}`;const o=t$1.children,[l]=o.contents.children,f=new i$1(o.tag,l);u$2(f,n);const y=f.comment(a,t$1.depth);y&&(e+=": ",e+=y),u||=f.noChildren;break}case f$4.SIMPLE_FLOAT:r===N$1.BREAK?e+="BREAK":t$1.ai>o$2.ONE?Object.is(r,-0)?e+="Float: -0":e+=`Float: ${r}`:(e+="Simple: ",r instanceof t?e+=r.value:e+=r);break}if(!u)if(t$1.leaf){if(e+=`
+`,n.length>i+1){const o=O$3((t$1.depth+1)*2);for(let l=i+1;l<n.length;l+=8)e+=o,e+=u$1(n.subarray(l,l+8)),e+=`
+`;}}else {e+=`
+`;let o=0;for(const l of t$1.children){if(E$1(l)){let f=String(o);t$1.mt===f$4.MAP?f=o%2?`val ${(o-1)/2}`:`key ${o/2}`:t$1.mt===f$4.TAG&&(f=""),e+=T(l,a,f);}o++;}}return e}const k={...w.defaultDecodeOptions,initialDepth:0,noPrefixHex:false,minCol:0};function I$1(t,a){const s={...k,...a,ParentType:C,saveOriginal:true},e=new u(t,s);let n,i;for(const r of e){if(i=w.create(r,n,s,e),r[2]===N$1.BREAK)if(n?.isStreaming)n.left=1;else throw new Error("Unexpected BREAK");if(!E$1(i)){const f=new C(r,0,n,s);f.leaf=true,f.children.push(i),u$2(f,e.toHere(r[3])),i=f;}let o=(i.depth+1)*2;const l=i.numBytes();for(l&&(o+=1,o+=l*2),s.minCol=Math.max(s.minCol,o),n&&n.push(i,e,r[3]),n=i;n?.done;)i=n,i.leaf||u$2(i,e.toHere(i.offset)),{parent:n}=n;}a&&(a.minCol=s.minCol);let u$3=s.noPrefixHex?"":`0x${u$1(e.toHere(0))}
+`;return u$3+=T(i,s),u$3}
+
+const R=!f$2();function B(e){if(typeof e=="object"&&e){if(e.constructor!==Number)throw new Error(`Expected number: ${e}`)}else if(typeof e!="number")throw new Error(`Expected number: ${e}`)}function f(e){if(typeof e=="object"&&e){if(e.constructor!==String)throw new Error(`Expected string: ${e}`)}else if(typeof e!="string")throw new Error(`Expected string: ${e}`)}function E(e){if(!(e instanceof Uint8Array))throw new Error(`Expected Uint8Array: ${e}`)}function U(e){if(!Array.isArray(e))throw new Error(`Expected Array: ${e}`)}ie(Map,(e,r,n)=>{const i=[...e.entries()].map(s=>[s[0],s[1],Y(s[0],n)]);if(n.rejectDuplicateKeys){const s=new Set;for(const[c,y,u]of i){const g=u$1(u);if(s.has(g))throw new Error(`Duplicate map key: 0x${g}`);s.add(g);}}n.sortKeys&&i.sort(n.sortKeys),F(e,e.size,f$4.MAP,r,n);for(const[s,c,y]of i)r.write(y),b(c,r,n);});function S(e){return f(e.contents),new Date(e.contents)}S.comment=e=>(f(e.contents),`(String Date) ${new Date(e.contents).toISOString()}`),i$1.registerDecoder(I$3.DATE_STRING,S);function h(e){return B(e.contents),new Date(e.contents*1e3)}h.comment=e=>(B(e.contents),`(Epoch Date) ${new Date(e.contents*1e3).toISOString()}`),i$1.registerDecoder(I$3.DATE_EPOCH,h),ie(Date,e=>[I$3.DATE_EPOCH,e.valueOf()/1e3]);function p(e,r,n){if(E(r.contents),n.rejectBigInts)throw new Error(`Decoding unwanted big integer: ${r}(h'${u$1(r.contents)}')`);if(n.requirePreferred&&r.contents[0]===0)throw new Error(`Decoding overly-large bigint: ${r.tag}(h'${u$1(r.contents)})`);let i=r.contents.reduce((s,c)=>s<<8n|BigInt(c),0n);if(e&&(i=-1n-i),n.requirePreferred&&i>=Number.MIN_SAFE_INTEGER&&i<=Number.MAX_SAFE_INTEGER)throw new Error(`Decoding bigint that could have been int: ${i}n`);return n.boxed?d$1(i,r.contents):i}const O$2=p.bind(null,false),N=p.bind(null,true);O$2.comment=(e,r)=>`(Positive BigInt) ${p(false,e,r)}n`,N.comment=(e,r)=>`(Negative BigInt) ${p(true,e,r)}n`,i$1.registerDecoder(I$3.POS_BIGINT,O$2),i$1.registerDecoder(I$3.NEG_BIGINT,N);function I(e,r){return E(e.contents),e}I.comment=(e,r,n)=>{E(e.contents);const i={...r,initialDepth:n+2,noPrefixHex:true},s=f$3(e);let y=2**((s[0]&31)-24)+1;const u=s[y]&31;let g=u$1(s.subarray(y,++y));u>=24&&(g+=" ",g+=u$1(s.subarray(y,y+2**(u-24)))),i.minCol=Math.max(i.minCol,(n+1)*2+g.length);const b=I$1(e.contents,i);let T=`Embedded CBOR
+`;return T+=`${"".padStart((n+1)*2," ")}${g}`.padEnd(i.minCol+1," "),T+=`-- Bytes (Length: ${e.contents.length})
+`,T+=b,T},I.noChildren=true,i$1.registerDecoder(I$3.CBOR,I),i$1.registerDecoder(I$3.URI,e=>(f(e.contents),new URL(e.contents)),"URI"),ie(URL,e=>[I$3.URI,e.toString()]),i$1.registerDecoder(I$3.BASE64URL,e=>(f(e.contents),l$2(e.contents)),"Base64url-encoded"),i$1.registerDecoder(I$3.BASE64,e=>(f(e.contents),s$1(e.contents)),"Base64-encoded"),i$1.registerDecoder(35,e=>(f(e.contents),new RegExp(e.contents)),"RegExp"),i$1.registerDecoder(21065,e=>{f(e.contents);const r=`^(?:${e.contents})$`;return new RegExp(r,"u")},"I-RegExp"),i$1.registerDecoder(I$3.REGEXP,e=>{if(U(e.contents),e.contents.length<1||e.contents.length>2)throw new Error(`Invalid RegExp Array: ${e.contents}`);return new RegExp(e.contents[0],e.contents[1])},"RegExp"),ie(RegExp,e=>[I$3.REGEXP,[e.source,e.flags]]),i$1.registerDecoder(64,e=>(E(e.contents),e.contents),"uint8 Typed Array");function d(e,r,n){E(e.contents);let i=e.contents.length;if(i%r.BYTES_PER_ELEMENT!==0)throw new Error(`Number of bytes must be divisible by ${r.BYTES_PER_ELEMENT}, got: ${i}`);i/=r.BYTES_PER_ELEMENT;const s=new r(i),c=new DataView(e.contents.buffer,e.contents.byteOffset,e.contents.byteLength),y=c[`get${r.name.replace(/Array/,"")}`].bind(c);for(let u=0;u<i;u++)s[u]=y(u*r.BYTES_PER_ELEMENT,n);return s}function A(e,r,n,i,s){const c=s.forceEndian??R;if(U$1(c?r:n,e,s),a$1(i.byteLength,e,f$4.BYTE_STRING),R===c)e.write(new Uint8Array(i.buffer,i.byteOffset,i.byteLength));else {const u=`write${i.constructor.name.replace(/Array/,"")}`,g=e[u].bind(e);for(const b of i)g(b,c);}}i$1.registerDecoder(65,e=>d(e,Uint16Array,false),"uint16, big endian, Typed Array"),i$1.registerDecoder(66,e=>d(e,Uint32Array,false),"uint32, big endian, Typed Array"),i$1.registerDecoder(67,e=>d(e,BigUint64Array,false),"uint64, big endian, Typed Array"),i$1.registerDecoder(68,e=>(E(e.contents),new Uint8ClampedArray(e.contents)),"uint8 Typed Array, clamped arithmetic"),ie(Uint8ClampedArray,e=>[68,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)]),i$1.registerDecoder(69,e=>d(e,Uint16Array,true),"uint16, little endian, Typed Array"),ie(Uint16Array,(e,r,n)=>A(r,69,65,e,n)),i$1.registerDecoder(70,e=>d(e,Uint32Array,true),"uint32, little endian, Typed Array"),ie(Uint32Array,(e,r,n)=>A(r,70,66,e,n)),i$1.registerDecoder(71,e=>d(e,BigUint64Array,true),"uint64, little endian, Typed Array"),ie(BigUint64Array,(e,r,n)=>A(r,71,67,e,n)),i$1.registerDecoder(72,e=>(E(e.contents),new Int8Array(e.contents)),"sint8 Typed Array"),ie(Int8Array,e=>[72,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)]),i$1.registerDecoder(73,e=>d(e,Int16Array,false),"sint16, big endian, Typed Array"),i$1.registerDecoder(74,e=>d(e,Int32Array,false),"sint32, big endian, Typed Array"),i$1.registerDecoder(75,e=>d(e,BigInt64Array,false),"sint64, big endian, Typed Array"),i$1.registerDecoder(77,e=>d(e,Int16Array,true),"sint16, little endian, Typed Array"),ie(Int16Array,(e,r,n)=>A(r,77,73,e,n)),i$1.registerDecoder(78,e=>d(e,Int32Array,true),"sint32, little endian, Typed Array"),ie(Int32Array,(e,r,n)=>A(r,78,74,e,n)),i$1.registerDecoder(79,e=>d(e,BigInt64Array,true),"sint64, little endian, Typed Array"),ie(BigInt64Array,(e,r,n)=>A(r,79,75,e,n)),i$1.registerDecoder(81,e=>d(e,Float32Array,false),"IEEE 754 binary32, big endian, Typed Array"),i$1.registerDecoder(82,e=>d(e,Float64Array,false),"IEEE 754 binary64, big endian, Typed Array"),i$1.registerDecoder(85,e=>d(e,Float32Array,true),"IEEE 754 binary32, little endian, Typed Array"),ie(Float32Array,(e,r,n)=>A(r,85,81,e,n)),i$1.registerDecoder(86,e=>d(e,Float64Array,true),"IEEE 754 binary64, big endian, Typed Array"),ie(Float64Array,(e,r,n)=>A(r,86,82,e,n)),i$1.registerDecoder(I$3.SET,e=>(U(e.contents),new Set(e.contents)),"Set"),ie(Set,e=>[I$3.SET,[...e]]),i$1.registerDecoder(I$3.JSON,e=>(f(e.contents),JSON.parse(e.contents)),"JSON-encoded"),i$1.registerDecoder(I$3.SELF_DESCRIBED,e=>e.contents,"Self-Described"),i$1.registerDecoder(I$3.INVALID_16,()=>{throw new Error(`Tag always invalid: ${I$3.INVALID_16}`)},"Invalid"),i$1.registerDecoder(I$3.INVALID_32,()=>{throw new Error(`Tag always invalid: ${I$3.INVALID_32}`)},"Invalid"),i$1.registerDecoder(I$3.INVALID_64,()=>{throw new Error(`Tag always invalid: ${I$3.INVALID_64}`)},"Invalid");function D(e){throw new Error(`Encoding ${e.constructor.name} intentionally unimplmented.  It is not concrete enough to interoperate.  Convert to Uint8Array first.`)}ie(ArrayBuffer,D),ie(DataView,D),typeof SharedArrayBuffer<"u"&&ie(SharedArrayBuffer,D);function m(e){return [NaN,e.valueOf()]}ie(Boolean,m),ie(Number,m),ie(String,m),ie(BigInt,m);
+
+function O$1(a,i={}){const n={...w.defaultDecodeOptions};if(i.dcbor?Object.assign(n,w.dcborDecodeOptions):i.cde&&Object.assign(n,w.cdeDecodeOptions),Object.assign(n,i),Object.hasOwn(n,"rejectLongNumbers"))throw new TypeError("rejectLongNumbers has changed to requirePreferred");n.boxed&&(n.saveOriginal=true);const t=new u(a,n);let e,r;for(const s of t){if(r=w.create(s,e,n,t),s[2]===N$1.BREAK)if(e?.isStreaming)e.left=0;else throw new Error("Unexpected BREAK");else e&&e.push(r,t,s[3]);for(r instanceof w&&(e=r);e?.done;){r=e.convert(t);const c=e.parent;c?.replaceLast(r,e,t),e=c;}}return r}
+
+const O="  ",y=new TextEncoder;class g extends w{close="";quote='"';get isEmptyStream(){return (this.mt===f$4.UTF8_STRING||this.mt===f$4.BYTE_STRING)&&this.count===0}}function a(m,l,n,p){let t="";if(l===o$2.INDEFINITE)t+="_";else {if(p.diagnosticSizes===o.NEVER)return "";{let r=p.diagnosticSizes===o.ALWAYS;if(!r){let e=o$2.ZERO;if(Object.is(n,-0))e=o$2.TWO;else if(m===f$4.POS_INT||m===f$4.NEG_INT){const T=n<0,u=typeof n=="bigint"?1n:1,o=T?-n-u:n;o<=23?e=Number(o):o<=255?e=o$2.ONE:o<=65535?e=o$2.TWO:o<=4294967295?e=o$2.FOUR:e=o$2.EIGHT;}else isFinite(n)?Math.fround(n)===n?s(n)==null?e=o$2.FOUR:e=o$2.TWO:e=o$2.EIGHT:e=o$2.TWO;r=e!==l;}r&&(t+="_",l<o$2.ONE?t+="i":t+=String(l-24));}}return t}function M(m,l){const n={...w.defaultDecodeOptions,...l,ParentType:g},p=new u(m,n);let t$1,r,e="";for(const T of p){const[u,o,i]=T;switch(t$1&&(t$1.count>0&&i!==N$1.BREAK&&(t$1.mt===f$4.MAP&&t$1.count%2?e+=": ":(e+=",",n.pretty||(e+=" "))),n.pretty&&(t$1.mt!==f$4.MAP||t$1.count%2===0)&&(e+=`
+${O.repeat(t$1.depth+1)}`)),r=w.create(T,t$1,n,p),u){case f$4.POS_INT:case f$4.NEG_INT:e+=String(i),e+=a(u,o,i,n);break;case f$4.SIMPLE_FLOAT:if(i!==N$1.BREAK)if(typeof i=="number"){const c=Object.is(i,-0)?"-0.0":String(i);e+=c,isFinite(i)&&!/[.e]/.test(c)&&(e+=".0"),e+=a(u,o,i,n);}else i instanceof t?(e+="simple(",e+=String(i.value),e+=a(f$4.POS_INT,o,i.value,n),e+=")"):e+=String(i);break;case f$4.BYTE_STRING:i===1/0?(e+="(_ ",r.close=")",r.quote="'"):(e+="h'",e+=u$1(i),e+="'",e+=a(f$4.POS_INT,o,i.length,n));break;case f$4.UTF8_STRING:i===1/0?(e+="(_ ",r.close=")"):(e+=JSON.stringify(i),e+=a(f$4.POS_INT,o,y.encode(i).length,n));break;case f$4.ARRAY:{e+="[";const c=a(f$4.POS_INT,o,i,n);e+=c,c&&(e+=" "),n.pretty&&i?r.close=`
+${O.repeat(r.depth)}]`:r.close="]";break}case f$4.MAP:{e+="{";const c=a(f$4.POS_INT,o,i,n);e+=c,c&&(e+=" "),n.pretty&&i?r.close=`
+${O.repeat(r.depth)}}`:r.close="}";break}case f$4.TAG:e+=String(i),e+=a(f$4.POS_INT,o,i,n),e+="(",r.close=")";break}if(r===N$1.BREAK)if(t$1?.isStreaming)t$1.left=0;else throw new Error("Unexpected BREAK");else t$1&&(t$1.count++,t$1.left--);for(r instanceof g&&(t$1=r);t$1?.done;){if(t$1.isEmptyStream)e=e.slice(0,-3),e+=`${t$1.quote}${t$1.quote}_`;else {if(t$1.mt===f$4.MAP&&t$1.count%2!==0)throw new Error(`Odd streaming map size: ${t$1.count}`);e+=t$1.close;}t$1=t$1.parent;}}return e}
+
+export const Tag = i$1;
+export const comment = I$1;
+export const decode = O$1;
+export const diagnose = M;
+export const encode = Y;
+export const registerEncoder = ie;
diff --git a/node_modules/@ngraveio/bc-ur/dist/esm/wrappers/cbor2Wrapper.js b/node_modules/@ngraveio/bc-ur/dist/esm/wrappers/cbor2Wrapper.js
index 99f3750..fdf13a4 100644
--- a/node_modules/@ngraveio/bc-ur/dist/esm/wrappers/cbor2Wrapper.js
+++ b/node_modules/@ngraveio/bc-ur/dist/esm/wrappers/cbor2Wrapper.js
@@ -1,6 +1,7 @@
 //@ts-ignore
-import { decode, encode, Tag, comment, diagnose } from 'cbor2';
-//@ts-ignore
-import { registerEncoder } from 'cbor2/encoder';
-export { decode, encode, Tag, registerEncoder, comment, diagnose };
+// import { decode, encode, Tag, comment, diagnose } from 'cbor2';
+// //@ts-ignore
+// import { registerEncoder } from 'cbor2/encoder';
+// export { decode, encode, Tag, registerEncoder, comment, diagnose };
+export { decode, encode, Tag, registerEncoder, comment, diagnose } from './cbor2Wrapper-fixed.js';
 //# sourceMappingURL=cbor2Wrapper.js.map
\ No newline at end of file
